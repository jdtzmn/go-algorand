// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
