// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XMkfLv5/AAAA//8pe3G6iCUBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
